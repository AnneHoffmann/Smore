#!/usr/bin/perl -w
## wrapper for smore tool

use Data::Dumper;
use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use POSIX qw(strftime);
use File::Basename;
use File::Find;
use IO::Uncompress::Gunzip qw($GunzipError);

##general information
my $toolname = "SMORE : Synteny Modulator Of Repetitive Elements";
my $version = "1.0";
my $citation ="
SMORE: Synteny Modulator Of Repetitive Elements. 
Berkemer, S.J. and Hoffmann, A. and Murray, C.R. and Stadler, P.F.
MDPI Life, 2017";
my $contact = "bsarah at bioinf dot uni-leipzig dot de or anneh at bioinf dot uni-leipzig dot de";
my $webpage = "www.github.com/AnneHoffmann/Smore";

my $mode = "";
##program mode
$mode = shift;
##general options
my $help;
my $cont;
my $vers;
my $cit;
my $helpout;
##options for all modes
my $toolpath;
my $outpath;
my $pythonpath;
my $perlpath;
##options for prep
my $refspecies;
my $genomes;
my $mafs;
my $trnas;
my $cmfile;
my $genelist;
my $locilist;
my $perc;
my $evalin="0.01";
my $bitvalin;
my $infernalpath;
my $trnaspath;
my $pseudoscore;
##options for toast and bake
my $pathtocam; #path to output of smore prep (genes folder)
my $seqsim =0.8;
my $strucsim =0.8;
my $newicktree;
my $ids;
my $joinmode = "relaxed";
my $skipm;
##options for verbose
my $printall;
my $printg;
my $printa;
my $printc;
#option for mix
my $maxclusnum=50000;
#options for roast
my $specieslist;
my $cluslistpath;
my $mixout;
my $roastout;

GetOptions(
#general
    'help|h' => \$help,
    'version|v' => \$vers,
    'citation' => \$cit,
    'contact' => \$cont,
    'helpout' => \$helpout,
#all modes
    'tool|t=s' => \$toolpath,
    'out|o=s' => \$outpath,
    'python=s' => \$pythonpath,
    'perl=s' => \$perlpath,
##options for prep
    'ref|r=s' => \$refspecies,
    'genomes|g=s' => \$genomes,
    'maf|m=s' => \$mafs,
    'trna' => \$trnas,
    'trnascan=s' => \$trnaspath,
    'cm|c=s' => \$cmfile,
    'genes=s' => \$genelist,
    'loci=s' => \$locilist,
    'filter=f' => \$perc,
    'incE=f' => \$evalin,
    'incT=f' => \$bitvalin,
    'infernal=s' => \$infernalpath,
    'pseudo=s' => \$pseudoscore,
##options for toast
    'prep=s' => \$pathtocam, #path to output of smore prep (genes folder)
    'seqsim|s=f' => \$seqsim,
    'strucsim|p=f' => \$strucsim,
    'newick=s' => \$newicktree,
    'id=s' => \$ids,
    'join=s' => \$joinmode,
    'nomiss' => \$skipm,
##options for verbose
    'verbose' => \$printall,
    'graph' => \$printg,
    'aln' => \$printa,
    'clus' => \$printc,
##for mix
    'max=s' => \$maxclusnum,
#for roast
    'species=s' => \$specieslist,
    'in|i=s' => \$cluslistpath,
#for eat
    'mix=s' => \$mixout,
    'roast=s' => \$roastout
    ) or die HelpShort();



if($help && $mode eq "bake"){HelpBake("helpBake.txt"); exit 0;}
if($help && $mode eq "prep"){HelpPrep("helpPrep.txt"); exit 0;}
if($help && $mode eq "toast"){HelpToast("helpToast.txt"); exit 0;}
if($help && $mode eq "mix"){HelpMix("helpMix.txt"); exit 0;}
if($help && $mode eq "roast"){HelpRoast("helpRoast.txt"); exit 0;}
if($help && $mode eq "eat"){HelpEat("helpEat.txt"); exit 0;}


my $doexit = 0;
if(! $mode){HelpShort(); exit 0;}
if($mode eq "help" || $mode eq "Help" ||
   $mode eq "--help" || $mode eq "-h" ||
   $mode eq "Recipe" || $mode eq "recipe")
{HelpShort();exit 0;}


##Help
if ($help){HelpShort();exit 0;}
##Version
if($mode eq "--version" || $mode eq "-v" || $vers){print "Program version $version \n"; $doexit = 1;}
##Contact
if($mode eq "--contact" || $cont){print "If you have further questions, please contact $contact or
see the manual at our github repository at: $webpage\n"; $doexit = 1;}
##Citation
if($mode eq "--citation" || $cit){print "If you use this program, please cite: $citation \n"; $doexit = 1;}
if($mode eq "--helpout" || $helpout ){HelpOut("helpOutput.txt"); $doexit = 1;}


if($doexit == 1){exit 0;}
my $parastr = "";

##outfolder
if(!$outpath){print STDERR "Please specify a location for the output files.\n"; exit 0;}
else{$parastr = "$parastr --out $outpath";}
#create outfolder if it doesnt exist
if(-e $outpath){}
else{
    my $cmd42= "mkdir $outpath";
    my @out42 = readpipe("$cmd42");
}

my $summary = "$outpath\/Summary\.txt";
open(my $outs,">>",$summary);

my $start_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
print $outs "$start_string -- Program started \n";


##parameters always needed
##tool
if(!$toolpath){
    $toolpath = dirname(__FILE__);
}
if(-e $toolpath){}
else{print STDERR "Please specify the path to where the tool's files are located.\n"; exit 0;}
$parastr = "$parastr --tool $toolpath";
##perl
if(!$perlpath){
    my $pepcmd = "which perl";
    my @pepcmdout = readpipe("$pepcmd");
    my $preperlpath = $pepcmdout[0];
    chomp($preperlpath);
    $perlpath = dirname($preperlpath);
}
if(-e $perlpath){}
else{print STDERR "Please specify the path to perl.\n";  exit 0;}
$parastr = "$parastr --perl $perlpath";
##python
if(!$pythonpath){
    my $pypcmd = "which python3";
    my @pypcmdout = readpipe("$pypcmd");
    my $prepythonpath = $pypcmdout[0];
    chomp($prepythonpath);
    $pythonpath = dirname($prepythonpath);
}
if(-e $pythonpath){}
else{print STDERR "Please specify the path to python.\n";  exit 0;}
$parastr = "$parastr --perl $perlpath";

######################################bake mode###############################
if($mode eq "bake" || $mode eq "Bake"){
##call prep and toast
    print $outs "in bake mode.\n";
    print $outs "Bake mode is composed of SMORE prep and SMORE toast.\n";
    my $start_prep = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "Prep mode started at $start_prep \n";
    ################################prep in bake##############################
    if(!$mafs){print STDERR "Please specify a location for the maf/MultiZ files.\n";  exit 0;}
    else{$parastr = "$parastr --maf $mafs";}
    ##refspecies
    if(!$refspecies){print STDERR "Please specify the name of the reference species as given in the maf/MultiZ files.\n";  exit 0;}
    else{$parastr = "$parastr --ref $refspecies";}
    my $filstr = "";
    ##filter
    if($perc){$filstr = " --filter $perc";}
    $parastr = "$parastr$filstr";
    my $preperrors = "$outpath\/errors_smoreprep\.txt";
    ##cm
    if($cmfile){
	$parastr = "$parastr --cm $cmfile";
	#we need genomes, infernalpath, (pseudoscore), (infernaloptions)
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	if(!$infernalpath){
            my $cmscmd = "which cmsearch";
            my @cmscmdout = readpipe("$cmscmd");
            my $preinfernalpath = $cmscmdout[0];
	    chomp($preinfernalpath);
	    $infernalpath = dirname($preinfernalpath);
        }
        if(-e $infernalpath){}
        else{print STDERR "Please specify the path to infernal.\n";  exit 0;}
	$parastr = "$parastr --infernal $infernalpath";
	my $infe = "";
	my $inft = "";
	if($evalin){$infe = " --incE $evalin";}
	if(!$evalin && $bitvalin){$inft = " --incT $bitvalin";}
	$parastr = "$parastr$infe$inft";
	print $outs "using a CM file with parameter: $parastr\n";
	##call prep script
	my $prepcm = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --cm $cmfile --genomes $genomes --infernal $infernalpath $infe $inft $filstr --err $preperrors 2>> $preperrors";
	my @outprepcm = readpipe("$prepcm");
	print $outs (join("",@outprepcm));
	print $outs "\n";
	my $pseudoval = -1;
	if($pseudoscore){$pseudoval = $pseudoscore;}
	my @checkOut = checkInfernalOut($outpath,$pseudoval);
	print $outs (join("",@checkOut));
    }
    elsif($genelist){
        #genelist
	$parastr = "$parastr --genes $genelist";
	print $outs "using a genelist with parameter: $parastr\n";
	my $checkgenelist = checkGeneList($genelist);
	if($checkgenelist eq "ok"){print $outs "gene list format checked!\n";}
	else{print STDERR "error in gene list: $checkgenelist\n"; exit 0;}
	#nothing more needed
	my $prepgl = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $genelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepgl = readpipe("$prepgl");
	print $outs (join("",@outprepgl));
	print $outs "\n";
    }
    elsif($locilist){
        #locilist
	$parastr = "$parastr --loci $locilist";
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	print $outs "using a locilist with parameter: $parastr\n";
	my $checklocilist = checkLociList($locilist);
	if($checklocilist eq "ok"){print $outs "loci list format checked!\n";}
	else{print STDERR "error in loci list: $checklocilist\n"; exit 0;}
	#we need: genomes
	#an extra script to create the input file
	my $locigenelist = getSeqs($genomes,$outpath,$toolpath,$perlpath,$preperrors,$locilist);
	##script:
	#unzip files
	#grep for species in locilist and have separate files
	#look for chr and coordinates and get sequence (take complement for - strand)
	#create format for genelist and add to genelist (secondary structure:NA)
	my $prepll = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $locigenelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepll = readpipe("$prepll");
	print $outs (join("",@outprepll));
	print $outs "\n";
    }
    elsif($trnas){
        #trnascan
	if(!$trnaspath){
            my $trnascmd = "which tRNAscan-SE";
            my @trnascmdout = readpipe("$trnascmd");
            my $pretrnaspath = $trnascmdout[0];
	    chomp($pretrnaspath);
	    $trnaspath = dirname($pretrnaspath);
        }
        if(-e $trnaspath){}
        else{print STDERR "Please specify the path to tRNAscan-SE.\n";  exit 0;}
	$parastr = "$parastr --trna --trnascan $trnaspath";
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	print $outs "using tRNAscan-SE with smore-prep-specific parameter: $parastr\n";

	my $start_trnas = strftime "%a %b %e %H:%M:%S %Y", localtime;
	print $outs "start tRNAscan-SE at $start_trnas\n";
	#trnascan
	my $tsgenelist = getTRNAs($trnaspath,$genomes,$outpath,$toolpath,$perlpath,$preperrors);
	my $end_trnas = strftime "%a %b %e %H:%M:%S %Y", localtime;
	print $outs "finish tRNAscan-SE at $end_trnas\n";
	
	my $prepts = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $tsgenelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepts = readpipe("$prepts");
	print $outs (join("",@outprepts));
	print $outs "\n";
    }
    else{print STDERR "Please one of the following options when in prep mode: cm, genes or loci.\n";  exit 0;}
    cleanPrepData($outpath);
    my $stop_prep = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "Prep mode finished at $stop_prep \n";
    ##############################toast in bake##################################
    my $start_toast = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "Toast mode started at $stop_prep \n";
    $pathtocam = $outpath;
    $parastr = "";
    my $toasterrors = "$outpath\/errors_smoretoast\.txt";
    #prep output
    if(!$pathtocam){print STDERR "Please specify the location of the output folders by SMORE prep.\n";  exit 0;}
    else{$parastr = "$parastr --prep $pathtocam";}
    my $specieslist = "$outpath\/specieslist";
    my $gencmd = "ls  $pathtocam\/genes \> $specieslist";
    my @outgncmd = readpipe("$gencmd");
    my $checkspecieslist = checkSpecList($specieslist);
    if($checkspecieslist eq "ok"){print $outs "species list format checked!\n";}
    else{print STDERR "error in species list: $checkspecieslist\n"; exit 0;}

    #tree
    if(!$newicktree){print STDERR "Please specify a newick tree representing the species' evolutionary relationship. \n";  exit 0;}
    else{$parastr = "$parastr --newick $newicktree";}
    my $formtree = "$outpath\/tree_formatted.newick";
    if($ids){
	#only convert tree identifier if id file is given
	my $formcmd = "$perlpath\/perl $toolpath\/extendTree.pl $newicktree $ids $formtree 2>> $toasterrors";
	my @formout = readpipe("$formcmd");
    }
    else{$formtree = $newicktree;}
    #check tree
    my $checkcmd1 = "$perlpath\/perl $toolpath\/checkTree.pl $formtree $specieslist 2>> $toasterrors";
    my @checkout1 = readpipe("$checkcmd1");
    my $noneout = "none";
    if(index($checkout1[0],$noneout) != -1){print $outs "Tree file consistent with genomes!\n";}
    else{
        print STDERR "The following speciesidentifier do appear in the genomes but do not appear in the tree: $checkout1[0]\n"; exit 0;
    }
    #join
    if($joinmode eq "relaxed" || $joinmode eq "strict" || $joinmode eq "none"){$parastr = "$parastr --join $joinmode";}
    else{print STDERR "Specify a valid option for the mode of joining. \n";  exit 0;}
    #output prints
    my $checkformissing = "";
    if($skipm){$checkformissing = " --nomiss";}
    $parastr = "$parastr$checkformissing";
    my $verbstr = "";
    if($printall){$verbstr = " --verbose";}
    else{
	if($printg){$verbstr = "$verbstr --graph";}
	if($printc){$verbstr = "$verbstr --clus";}
	if($printa){$verbstr = "$verbstr --aln";}
    }
    $parastr = "$parastr$verbstr";
    print $outs "with smore-toast-specific parameter: $parastr\n";
    my $toastcmd = "$perlpath\/perl $toolpath\/smoretoast.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --prep $pathtocam --seqsim $seqsim --strucsim $strucsim --newick $formtree --join $joinmode --species $specieslist$checkformissing --err $toasterrors $verbstr 2>> $toasterrors";
    my @outtoast = readpipe("$toastcmd");
    print $outs (join("",@outtoast));
    print $outs "\n";

    my $stop_toast = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "Finished toast mode at $stop_toast \n";

    print $outs "Output files of SMORE bake can be found here: $outpath \n";
    print $outs "The final tree can be visualized using the online tool iTOL. Files to be uploaded on the iTOL page are located in $outpath\/data_iTOL\n";
    print $outs "For more information on SMORE bake output, use 'SMORE --helpout' or check the manual.\n";

    my $stop_bake = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_bake -- Program finished \n";    
}

######################################prep mode###############################
elsif($mode eq "prep" || $mode eq "Prep")
{
    print $outs "in prep mode.\n";
    ##maf
    if(!$mafs){print STDERR "Please specify a location for the maf/MultiZ files.\n";  exit 0;}
    else{$parastr = "$parastr --maf $mafs";}
    ##refspecies
    if(!$refspecies){print STDERR "Please specify the name of the reference species as given in the maf/MultiZ files.\n";  exit 0;}
    else{$parastr = "$parastr --ref $refspecies";}
    my $filstr = "";
    ##filter
    if($perc){$filstr = " --filter $perc";}
    $parastr = "$parastr$filstr";
    my $preperrors = "$outpath\/errors_smoreprep\.txt";
    ##cm
    if($cmfile){
	$parastr = "$parastr --cm $cmfile";
	#we need genomes, infernalpath, (pseudoscore), (infernaloptions)
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	if(!$infernalpath){
            my $cmscmd = "which cmsearch";
            my @cmscmdout = readpipe("$cmscmd");
            my $preinfernalpath = $cmscmdout[0];
	    chomp($preinfernalpath);
	    $infernalpath = dirname($preinfernalpath);
        }
        if(-e $infernalpath){}
        else{print STDERR "Please specify the path to infernal.\n";  exit 0;}
	$parastr = "$parastr --infernal $infernalpath";
	my $infe = "";
	my $inft = "";
	if($evalin){$infe = " --incE $evalin";}
	if(!$evalin && $bitvalin){$inft = " --incT $bitvalin";}
	$parastr = "$parastr$infe$inft";
	print $outs "using a CM file with parameter: $parastr\n";
	##call prep script
	my $prepcm = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --cm $cmfile --genomes $genomes --infernal $infernalpath $infe $inft $filstr --err $preperrors 2>> $preperrors";
	my @outprepcm = readpipe("$prepcm");
	print $outs (join("",@outprepcm));
	print $outs "\n";
	##format of output lists in gene folder: chr spec_id start end strand blockl blockr struc seq infernal_score
	##check infernal scores for each species, min, max, sum, num
	my $pseudoval = -1;
	if($pseudoscore){$pseudoval = $pseudoscore;}
	my @checkOut = checkInfernalOut($outpath,$pseudoval);
	print $outs (join("",@checkOut));
    }
    elsif($genelist){
        #genelist
	$parastr = "$parastr --genes $genelist";
	print $outs "using a genelist with parameter: $parastr\n";
	my $checkgenelist = checkGeneList($genelist);
	if($checkgenelist eq "ok"){print $outs "gene list format checked!\n";}
	else{print STDERR "error in gene list: $checkgenelist\n"; exit 0;}
	#nothing more needed
	my $prepgl = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $genelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepgl = readpipe("$prepgl");
	print $outs (join("",@outprepgl));
	print $outs "\n";
    }
    elsif($locilist){
        #locilist
	$parastr = "$parastr --loci $locilist";
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	print $outs "using a locilist with parameter: $parastr\n";
	my $checklocilist = checkLociList($locilist);
	if($checklocilist eq "ok"){print $outs "loci list format checked!\n";}
	else{print STDERR "error in loci list: $checklocilist\n"; exit 0;}
	#we need: genomes
	#an extra script to create the input file
	my $locigenelist = getSeqs($genomes,$outpath,$toolpath,$perlpath,$preperrors,$locilist);
	##script:
	#unzip files
	#grep for species in locilist and have separate files
	#look for chr and coordinates and get sequence (take complement for - strand)
	#create format for genelist and add to genelist (secondary structure:NA)
	my $prepll = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $locigenelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepll = readpipe("$prepll");
	print $outs (join("",@outprepll));
	print $outs "\n";
    }
    elsif($trnas){
        #trnascan
	if(!$trnaspath){
            my $trnascmd = "which tRNAscan-SE";
            my @trnascmdout = readpipe("$trnascmd");
            my $pretrnaspath = $trnascmdout[0];
	    chomp($pretrnaspath);
	    $trnaspath = dirname($pretrnaspath);
        }
        if(-e $trnaspath){}
        else{print STDERR "Please specify the path to tRNAscan-SE.\n";  exit 0;}
	$parastr = "$parastr --trna --trnascan $trnaspath";
	if(!$genomes){print STDERR "Please specify the path to where the genomes are located.\n";  exit 0;}
	else{$parastr = "$parastr --genomes $genomes";}
	print $outs "using tRNAscan-SE with parameter: $parastr\n";

	my $start_trnas = strftime "%a %b %e %H:%M:%S %Y", localtime;
	print $outs "start tRNAscan-SE at $start_trnas\n";
	#trnascan
	my $tsgenelist = getTRNAs($trnaspath,$genomes,$outpath,$toolpath,$perlpath,$preperrors);
	my $end_trnas = strftime "%a %b %e %H:%M:%S %Y", localtime;
	print $outs "finish tRNAscan-SE at $end_trnas\n";
	
	my $prepts = "$perlpath\/perl $toolpath\/smoreprep.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --maf $mafs --ref $refspecies --genes $tsgenelist $filstr --err $preperrors 2>> $preperrors";
	my @outprepts = readpipe("$prepts");
	print $outs (join("",@outprepts));
	print $outs "\n";
    }
    else{print STDERR "Please one of the following options when in prep mode: cm, genes or loci.\n";  exit 0;}

    cleanPrepData($outpath);
    
    print $outs "Output files of SMORE prep can be found here: $outpath \n";
    print $outs "Please specify this path in the --prep option when running SMORE toast or SMORE bake. \n";
    print $outs "For more information on SMORE prep output, please check the manual.\n";
    my $stop_prep = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_prep -- Program finished \n";
}

######################################toast mode###############################
elsif($mode eq "toast" || $mode eq "Toast")
{
    print $outs "in toast mode.\n";
    my $toasterrors = "$outpath\/errors_smoretoast\.txt";
    #prep output
    if(!$pathtocam){print STDERR "Please specify the location of the output folders by SMORE prep.\n";  exit 0;}
    else{$parastr = "$parastr --prep $pathtocam";}
    my $specieslist = "$outpath\/specieslist";
    my $gencmd = "ls  $pathtocam\/genes \> $specieslist";
    my @outgncmd = readpipe("$gencmd");
    my $checkspecieslist = checkSpecList($specieslist);
    if($checkspecieslist eq "ok"){print $outs "species list format checked!\n";}
    else{print STDERR "error in species list: $checkspecieslist\n"; exit 0;}
    #tree
    if(!$newicktree){print STDERR "Please specify a newick tree representing the species' evolutionary relationship. \n";  exit 0;}
    else{$parastr = "$parastr --newick $newicktree";}
    my $formtree = "$outpath\/tree_formatted.newick";
    if($ids){
	#only convert tree identifier if id file is given
	my $formcmd = "$perlpath\/perl $toolpath\/extendTree.pl $newicktree $ids $formtree 2>> $toasterrors";
	my @formout = readpipe("$formcmd");
    }
    else{$formtree = $newicktree;}
    #check tree
    my $checkcmd1 = "$perlpath\/perl $toolpath\/checkTree.pl $formtree $specieslist 2>> $toasterrors";
    my @checkout1 = readpipe("$checkcmd1");
    my $noneout = "none";
    if(index($checkout1[0],$noneout) != -1){print $outs "Tree file consistent with genomes!\n";}
    else{
        print STDERR "The following speciesidentifier do appear in the genomes but do not appear in the tree: $checkout1[0]\n"; exit 0;
    }
    #join
    if($joinmode eq "relaxed" || $joinmode eq "strict" || $joinmode eq "none"){$parastr = "$parastr --join $joinmode";}
    else{print STDERR "Specify a valid option for the mode of joining. \n";  exit 0;}
    #output prints
    my $checkformissing = "";
    if($skipm){$checkformissing = " --nomiss";}
    $parastr = "$parastr$checkformissing";
    my $verbstr = "";
    if($printall){$verbstr = " --verbose";}
    else{
	if($printg){$verbstr = "$verbstr --graph";}
	if($printc){$verbstr = "$verbstr --clus";}
	if($printa){$verbstr = "$verbstr --aln";}
    }
    $parastr = "$parastr$verbstr";
    print $outs "with parameter: $parastr\n";
    my $toastcmd = "$perlpath\/perl $toolpath\/smoretoast.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --prep $pathtocam --seqsim $seqsim --strucsim $strucsim --newick $formtree --join $joinmode --species $specieslist$checkformissing --err $toasterrors $verbstr 2>> $toasterrors";
    my @outtoast = readpipe("$toastcmd");
    print $outs (join("",@outtoast));
    print $outs "\n";
    print $outs "Output files of SMORE toast can be found here: $outpath \n";
    print $outs "The final tree can be visualized using the online tool iTOL. Files to be uploaded on the iTOL page are located in $outpath\/data_iTOL\n";
    print $outs "For more information on SMORE toast output, use 'SMORE --helpout' or check the manual.\n";
    my $stop_toast = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_toast -- Program finished \n";
}
######################################mix mode###############################
elsif($mode eq "mix" || $mode eq "Mix"){
    print $outs "in mix mode.\n";
    ##mix parameter: 
    my $mixerrors = "$outpath\/errors_smoremix\.txt";
    #prep output
    if(!$pathtocam){print STDERR "Please specify the location of the output folders by SMORE prep.\n";  exit 0;}
    else{$parastr = "$parastr --prep $pathtocam";}
    my $specieslist = "$outpath\/specieslist";
    my $gencmd = "ls  $pathtocam\/genes \> $specieslist";
    my @outgncmd = readpipe("$gencmd");
    my $checkspecieslist = checkSpecList($specieslist);
    if($checkspecieslist eq "ok"){print $outs "species list format checked!\n";}
    else{print STDERR "error in species list: $checkspecieslist\n"; exit 0;}

    #join
    if($joinmode eq "relaxed" || $joinmode eq "strict" || $joinmode eq "none"){$parastr = "$parastr --join $joinmode";}
    else{print STDERR "Specify a valid option for the mode of joining. \n";  exit 0;}
    #output prints
    my $checkformissing = "";
    if($skipm){$checkformissing = " --nomiss";}
    $parastr = "$parastr$checkformissing";
    my $verbstr="";
    if($printc || $printall){$verbstr = "$verbstr --clus";}
    #tree
    if(!$newicktree){print STDERR "Please specify a newick tree representing the species' evolutionary relationship. \n";  exit 0;}
    else{$parastr = "$parastr --newick $newicktree";}
    my $formtree = "$outpath\/tree_formatted.newick";
    if($ids){
	#only convert tree identifier if id file is given
	my $formcmd = "$perlpath\/perl $toolpath\/extendTree.pl $newicktree $ids $formtree 2>> $mixerrors";
	my @formout = readpipe("$formcmd");
    }
    else{$formtree = $newicktree;}
    #check tree
    my $checkcmd1 = "$perlpath\/perl $toolpath\/checkTree.pl $formtree $specieslist 2>> $mixerrors";
    my @checkout1 = readpipe("$checkcmd1");
    my $noneout = "none";
    if(index($checkout1[0],$noneout) != -1){print $outs "Tree file consistent with genomes!\n";}
    else{
        print STDERR "The following speciesidentifier do appear in the genomes but do not appear in the tree: $checkout1[0]\n"; exit 0;
    }
##change to mix mode
    print $outs "with parameter: $parastr\n";
    my $mixcmd = "$perlpath\/perl $toolpath\/smoremix.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --prep $pathtocam --seqsim $seqsim --strucsim $strucsim --newick $formtree --join $joinmode --species $specieslist$checkformissing --err $mixerrors $verbstr --max $maxclusnum 2>> $mixerrors";
    my @outmix = readpipe("$mixcmd");
    print $outs (join("",@outmix));
    print $outs "\n";
    print $outs "Output files of SMORE mix can be found here: $outpath \n";
    print $outs "List of commands to further process SMORE mix output can be found in $outpath\/commandlist.txt.\n";
    print $outs "For more information on SMORE mix output, use 'SMORE --helpout' or 'SMORE --help' or check the manual.\n";
    my $stop_mix = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_mix -- Program finished \n";
}
######################################roast mode###############################
elsif($mode eq "roast" || $mode eq "Roast"){

    print $outs "in roast mode.\n";
    #prep output
    if(! $cluslistpath){print STDERR "Please specify the list of clusters to be analysed with SMORE roast.\n"; exit 0;}
    else{$parastr = "$parastr --in $cluslistpath";}
    #species
    if(! $specieslist){print STDERR "Please specify the list of species.\n"; exit 0;}
    else{$parastr = "$parastr --species $specieslist";}
    my $checkspecieslist = checkSpecList($specieslist);
    if($checkspecieslist eq "ok"){print $outs "species list format checked!\n";}
    else{print STDERR "error in species list: $checkspecieslist\n"; exit 0;}

    #tree
    if(!$newicktree){print STDERR "Please specify a newick tree representing the species' evolutionary relationship. \n";  exit 0;}
    else{$parastr = "$parastr --newick $newicktree";}
    my $formtree = "$outpath\/tree_formatted.newick";
    if($ids){
	#only convert tree identifier if id file is given
	my $formcmd = "$perlpath\/perl $toolpath\/extendTree.pl $newicktree $ids $formtree";
	my @formout = readpipe("$formcmd");
    }
    else{$formtree = $newicktree;}
    #check tree
    my $checkcmd1 = "$perlpath\/perl $toolpath\/checkTree.pl $formtree $specieslist";
    my @checkout1 = readpipe("$checkcmd1");
    my $noneout = "none";
    if(index($checkout1[0],$noneout) != -1){print $outs "Tree file consistent with genomes!\n";}
    else{
        print STDERR "The following speciesidentifier do appear in the genomes but do not appear in the tree: $checkout1[0]\n"; exit 0;
    }
    #output prints
    my $checkformissing = "";
    if($skipm){$checkformissing = " --nomiss";}
    $parastr = "$parastr$checkformissing";
    my $verbstr = "";
    if($printall){$verbstr = " --verbose";}
    else{
	if($printg){$verbstr = "$verbstr --graph";}
	if($printa){$verbstr = "$verbstr --aln";}
    }
    $parastr = "$parastr$verbstr";
    print $outs "with parameter: $parastr\n";
    my $roastcmd = "$perlpath\/perl $toolpath\/smoreroast.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --in $cluslistpath --seqsim $seqsim --strucsim $strucsim --newick $formtree --species $specieslist$checkformissing $verbstr";
    my @outroast = readpipe("$roastcmd");
    print $outs (join("",@outroast));
    print $outs "\n";
    print $outs "Output files of SMORE roast can be found here: $outpath \n";
    print $outs "To summarize all output files and finish the analysis, please use 'SMORE eat'.\n";
    print $outs "For more information on SMORE roast and SMORE eat, use 'SMORE --help' or 'SMORE --helpout' or check the manual.\n";
    my $stop_roast = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_roast -- Program finished \n";
}
######################################eat mode###############################
elsif($mode eq "eat" || $mode eq "Eat"){
    my $eaterrors = "$outpath\/errors_smoreeat\.txt";
    if(!$pathtocam){print STDERR "Please specify the location of the output folders by SMORE prep.\n";  exit 0;}
    else{$parastr = "$parastr --prep $pathtocam";}
    if(!$mixout){print STDERR "Please specify the location of the output folders by SMORE mix.\n";  exit 0;}
    else{$parastr = "$parastr --mix $mixout";}
    if(!$roastout){print STDERR "Please specify the location of the output folders by SMORE roast.\n";  exit 0;}
    else{$parastr = "$parastr --roast $roastout";}
    if(!$newicktree){print STDERR "Please specify a newick tree representing the species' evolutionary relationship. \n";  exit 0;}
    else{$parastr = "$parastr --newick $newicktree";}
    my $formtree = "$outpath\/tree_formatted.newick";
    if($ids){
	#only convert tree identifier if id file is given
	my $formcmd = "$perlpath\/perl $toolpath\/extendTree.pl $newicktree $ids $formtree 2>> $eaterrors";
	my @formout = readpipe("$formcmd");
    }
    else{$formtree = $newicktree;}

    my $tmpspecieslist = "$outpath\/tmp_specieslist";
    my $gencmd = "ls  $pathtocam\/genes \> $tmpspecieslist";
    my @outgncmd = readpipe("$gencmd");
    my $checkspecieslist = checkSpecList($tmpspecieslist);
    if($checkspecieslist eq "ok"){print $outs "species list format checked!\n";}
    else{print STDERR "error in species list: $checkspecieslist\n"; exit 0;}

    #check tree
    my $checkcmd1 = "$perlpath\/perl $toolpath\/checkTree.pl $formtree $tmpspecieslist 2>> $eaterrors";
    my @checkout1 = readpipe("$checkcmd1");
    my $noneout = "none";
    if(index($checkout1[0],$noneout) != -1){print $outs "Tree file consistent with genomes!\n";}
    else{
        print STDERR "The following speciesidentifier do appear in the genomes but do not appear in the tree: $checkout1[0]\n"; exit 0;
    }
    my $tmprmcmd = "rm $tmpspecieslist";
    readpipe("$tmprmcmd");
    #output prints
    my $checkformissing = "";
    if($skipm){$checkformissing = " --nomiss";}
    $parastr = "$parastr$checkformissing";

    print $outs "with parameter: $parastr\n";
    my $eatcmd = "$perlpath\/perl $toolpath\/smoreeat.pl --tool $toolpath --out $outpath --python $pythonpath --perl $perlpath --prep $pathtocam --mix $mixout --roast $roastout --newick $formtree$checkformissing 2> $eaterrors";
    my @outeat = readpipe("$eatcmd");
    print $outs (join("",@outeat));
    print $outs "\n";
    print $outs "Output files of SMORE eat can be found here: $outpath \n";
    print $outs "The final tree can be visualized using the online tool iTOL. Files to be uploaded on the iTOL page are located in $outpath\/data_iTOL\n";
    print $outs "For more information on SMORE eat, use 'SMORE --help' or 'SMORE --helpout' or check the manual.\n";
    my $stop_eat = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $outs "$stop_eat -- Program finished \n";


}
######################################invalid mode###############################
#if($mode ne "eat" && $mode ne "Eat" && $mode ne "roast" && $mode ne "Roast" && $mode ne "mix" && $mode ne "Mix" && $mode ne "toast" && $mode ne "Toast" && $mode ne "bake" && $mode ne "Bake" && $mode ne "prep" && $mode ne "Prep")
else{print "\'$mode\' is not a valid option! \n";  exit 0;}


sub HelpShort{
print "
This is the short help page of the SMORE pipeline, a Synteny Modulator Of Repetitive Elements.
usage: ./SMORE <subcommand> [options]

or ./SMORE [general_options]

For subcommands' help pages:
./SMORE <subcommand> --help

The general options are:
        --help|-h       print help page
	--version|-v    print version information
	--citation	print citation information
	--contact       print contact information
        --helpout       print explanation for structure and visualization of
	                output files

For more information about the subcommands use: SMORE <subcommand> --help
More detailed information about the output can be found using: SMORE --helpout

The SMORE subcommands are:

    bake    The subcommand bake combines the subcommands prep and toast in
            order to easily start and run the pipeline completely. Hence,
	    parameters for bake are the same as the combined parameters
	    for prep and toast.

    prep    This program will sort genetic elements in between genomic anchors
            based on MultiZ alignments. The genetic elements are
            taken from a list given as input or retrieved based on a covariance
	    model as input for infernal.

    toast   This program will take the prep-output and calculate the numbers
            for evolutionary events at the given phylogenetic tree.
            For a more detailed insight, the verbose mode can be used to print
            intermediary files such as clusters, graphs and/or alignments

    mix     This subcommand can be used after running SMORE prep. SMORE mix
            only produces a list of genetic clusters. This can be used to
	    test different joining methods. Additionally, SMORE mix can split
	    the number of clusters in several disjoint lists such that the
	    succeeding subcommands can be run in parallel on the disjoint
	    subsets to speed up running time of the program for large
	    data sets. In case SMORE mix is splitting the list of clusters,
	    it will output a command list that can be called to continue
	    running the pipeline. The next subcommand to be called is
	    SMORE roast.

    roast   SMORE roast starts from a list of genetic clusters and will output
            lists of genetic events that can be further proceeded as an input
	    for SMORE eat. SMORE roast can be used for large data sets in order
	    to split and parallelize the process. The next subcommand in the
	    pipeline will be SMORE eat.

    eat     This subcommand is used after SMORE roast and will take list(s) of
            evolutionary events and output a phylogenetic tree with event and
	    element counts. SMORE eat is able to summarize the outputs of parallelized
	    runs such that all data is recombined at the phylogenetic tree.

The SMORE manual can be downloaded at $webpage.
";


}


sub HelpBake{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}

sub HelpPrep{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}


sub HelpToast{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}

sub HelpMix{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}

sub HelpRoast{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}

sub HelpEat{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}




sub HelpOut{
    my @inp = @_;
    my $infile = $inp[0];
    open FA,"<$infile" or die "can't open $infile\n";
    while(<FA>){
	my $line = $_;
	print $line;
    }
}




sub getTRNAs{#  ($trnaspath,$genomes,outpath,toolpath,perlpath,$preperrors)
    my @inp = @_;
#    my $pathes = join('\n',@inp);
    #    print STDERR "$pathes\n";
    my $tspath = "$outpath\/temp\_trnascan";
    my $folcmd = "mkdir $tspath";
    readpipe("$folcmd");
    my $trnaspath = $inp[0];
    my $genomes = $inp[1];
    my $outpath = $inp[2];
    my $toolpath = $inp[3];
    my $perlpath = $inp[4];
    my $preperrors = $inp[5];
    my $outfile = "$outpath\/genelist.bed";
    my $listcmd = "ls $genomes";
    my @genomeslist = readpipe("$listcmd");
    my @scripts = ();
    my $checkfile = "$tspath\/DoneList.txt";
    my $cfcmd = "touch $checkfile";
    readpipe("$cfcmd");
    for(my $i = 0;$i< scalar @genomeslist; $i++){
	my $curgenome = $genomeslist[$i];
	chomp($curgenome);	
	my @splitgen = split '\.', $curgenome;
	my $curgen = $splitgen[0];
#	print STDERR "current genome: $curgenome, current species: $curgen \n";
	my $tscmd;
	my $zipd = 0;
	##tRNAscan-SE does not work with zcat!!! unzip files before!
	##create shell scripts for each of the species including unzip,trnascan and rm files
	my $curscript = "$tspath\/$curgen\_ts\.sh";
	open(my $curs,">>", $curscript);
	print $curs "#!/bin/sh\n";
	if($splitgen[-1] eq "gz"){
	    print $curs "gunzip -c -k $genomes/$curgenome > $tspath\/$curgen\.fa 2>> $preperrors\n";
	    #readpipe("$unzcmd");
	    print $curs "$trnaspath\/tRNAscan-SE -q -f $tspath\/$curgen\.sec $tspath\/$curgen\.fa 2>> $preperrors\n";
	    print $curs "$perlpath\/perl $toolpath\/getGenlist_tRNAs.pl $tspath\/$curgen\.sec $curgen $tspath\/tmpparse$curgen\.bed 2>> $preperrors\n";
	    print $curs "cat $tspath\/tmpparse$curgen\.bed >> $outfile\n";
	    print $curs "rm $tspath\/tmpparse$curgen\.bed $tspath\/$curgen\.fa $tspath\/$curgen\.sec\n";
	    print $curs "echo \"$curgen\" >> $checkfile\n";
	}
	else{
	    print $curs "$trnaspath\/tRNAscan-SE -q -f $tspath\/$curgen\.sec $genomes/$curgenome 2>> $preperrors\n";
	    print $curs "$perlpath\/perl $toolpath\/getGenlist_tRNAs.pl $tspath\/$curgen\.sec $curgen $tspath\/tmpparse$curgen\.bed 2>> $preperrors\n";
	    print $curs "cat $tspath\/tmpparse$curgen\.bed >> $outfile\n";
	    print $curs "rm $tspath\/tmpparse$curgen\.bed $tspath\/$curgen\.sec\n";
	    print $curs "echo \"$curgen\" >> $checkfile\n";
	}
	close $curs;
	push @scripts, $curscript;
    }

    my $allscript = "$tspath\/runTS.sh";
    open(my $as,">>",$allscript);
    print $as "#!/bin/sh\n";
    my $emp = "&";
    for(my $i=0;$i<scalar @scripts;$i++){
	print $as "/bin/bash $scripts[$i] $emp\n";
	if($emp eq "&"){$emp = "";}
	else{$emp="&";}
    }
    my $ascmd = "/bin/bash $allscript 2>> $preperrors";
    readpipe("$ascmd");
    my $rminfoldercmd = "rm $tspath\/\*\.sh";
    readpipe("$rminfoldercmd");
    my $rmfoldercmd = "rm -rf $tspath";
    readpipe("$rmfoldercmd");
    return $outfile;
}


sub getSeqs{
    my @inp=@_;
    my $genomes = $inp[0];
    my $outpath = $inp[1];
    my $toolpath = $inp[2];
    my $perlpath = $inp[3];
    my $preperrors = $inp[4];
    open(my $oute,">>",$preperrors);
    my $locilist = $inp[5];
    my $outfile = "$outpath\/genelist.bed";
    open(my $outf,">>",$outfile);
    my $listcmd = "ls $genomes";
    my @genomeslist = readpipe("$listcmd");
    for(my $i = 0;$i< scalar @genomeslist; $i++){
	my $curgenome = $genomeslist[$i];
	chomp($curgenome);	
	my @splitgen = split '\.', $curgenome;
	my $curgen = $splitgen[0];
	my %chrs = (); #hash with chromosome and sequence
	if($splitgen[-1] eq "gz"){
	    my $CTF = IO::Uncompress::Gunzip->new( "$genomes\/$curgenome" )
		or die "IO::Uncompress::Gunzip failed: $genomes\/$curgenome\n";
	    my $curstr = "";
	    my $curkey = "";
	    while(<$CTF>){
		chomp;
		my $tmpline = $_;
		if($tmpline =~ /^>/){
		    if($curstr ne ""){
			$chrs{$curkey} = $curstr;
		    }
		    $curstr = "";
		    $curkey = substr($tmpline,1);
		}
		else{
		    $curstr = "$curstr$tmpline";
		}
	    }
	}
	else{
	    my $curstr = "";
	    my $curkey = "";
	    open FA,"$genomes\/$curgenome" or die "can't open $genomes\/$curgenome\n";
	    while(<FA>){
		chomp;
		my $tmpline = $_;
		if($tmpline =~ /^>/){
		    if($curstr ne ""){
			$chrs{$curkey} = $curstr;
		    }
		    $curstr = "";
		    $curkey = substr($tmpline,1);
		}
		else{
		    $curstr = "$curstr$tmpline";
		}
	    }
	}
	open FB,"$locilist" or die "can't open $locilist\n";
	while(<FB>){
	    chomp;
	    my $line = $_;
	    my @F = split '\t', $line;
	    my $lenf = scalar @F;
	    if(scalar @F != 7){print $oute "locilist has $lenf entries instead of 7!\n";}
	    if($curgen ne $F[3]){next;}
	    my $s;
	    my $e;
	    if($F[1] < $F[2]){
		$s = $F[1];
		$e = $F[2];
	    }
	    else{
		$s = $F[2];
		$e = $F[1];
	    }
	    my $preseq;
	    if(exists($chrs{$F[0]})){
		my $len = $e-$s;
		##when comparing tRNAscan output, s-1 and len+1 fits
		$preseq = substr($chrs{$F[0]},$s-1,$len+1);
	    }
	    else{print $oute "ERROR: chromosome $F[0] of species $F[3] does not exist!\n";next;}
	    my $finalseq;
	    if($F[4] eq '+'){$finalseq = $preseq;}
	    else{$finalseq = getComplement(lc($preseq));}
	    my $outline = "$line\tNA\t$finalseq\tNA";
	    print $outf "$outline\n";
	}
    } #end for genomeslist
    close $outf;
    close $oute;
    return $outfile;
}


sub getComplement{
    my @inp = @_;
    my $str = $inp[0];
#    print "getComplement in str: $str\n";
#    my $str = uc($instr);
    my $newstr = "";
    my $a = "a";
    my $c = "c";
    my $g = "g";
    my $t = "t";
    my $n = "n";
    my @tmpstr = split "", $str;
    for(my $i = (scalar @tmpstr)-1; $i>=0;$i--) {
	if($tmpstr[$i] eq $a)   {$newstr = "$newstr$t";}
	elsif($tmpstr[$i] eq $t){$newstr = "$newstr$a";}
	elsif($tmpstr[$i] eq $g){$newstr = "$newstr$c";}
	elsif($tmpstr[$i] eq $c){$newstr = "$newstr$g";}
	else{$newstr = "$newstr$n";}
    }
    return $newstr;
}


sub checkSpecList{
    my @inp = @_;
    my $infile = $inp[0];
    my %spec = ();
    my $res = "ok";
    open FB,"$infile" or die "can't open $infile\n";
    while(<FB>){
	chomp;
	my $line = $_;
	my @F = split '\.', $line;
	if($F[0] eq ""){$res="empty filename!"; last;}
	if(exists($spec{$F[0]})){
	    $res = "deduplicated species name!"; last;
	}
	else{$spec{$F[0]}=1;}
    }
    return $res;
}


sub checkGeneList{
    my @inp = @_;
    my $genelist = $inp[0];
    my $entries_genelist = 10;
    my $res = "ok";
    open FB,"$genelist" or die "can't open $genelist\n";
    my $linenum = 0;
    while(<FB>){
	chomp;
	my $line = $_;
	my @F = split "\t", $line;
	my $entries = scalar @F;
	if($entries != $entries_genelist){$res = "line $linenum has $entries entries instead of $entries_genelist!";last;}
	$linenum++;
    }
    return $res;



}


sub checkLociList{
    my @inp = @_;
    my $locilist = $inp[0];
    my $entries_locilist = 7;
    my $res = "ok";
    open FB,"$locilist" or die "can't open $locilist\n";
    my $linenum = 0;
    while(<FB>){
	chomp;
	my $line = $_;
	my @F = split "\t", $line;
	my $entries = scalar @F;
	if($entries != $entries_locilist){$res = "line $linenum has $entries entries instead of $entries_locilist!";last;}
	$linenum++;
    }
    return $res;
}


sub cleanPrepData{
    ##this sub is to sort and filter(uniq) smore prep output as duplicated list entries might exist
    my @inp = @_;
    my $outpath = $inp[0];
    my $tmplist = "$outpath\/list_genesfiles";
    my $lscmd = "ls $outpath\/genes > $tmplist";
    readpipe("$lscmd");
    my $tmpfolder = "$outpath\/tmp_genes";
    my $mkcmd = "mkdir $tmpfolder";
    readpipe("$mkcmd");
    open FA,"<$tmplist" or die "can't open $tmplist\n";
    while(<FA>){
	chomp;
	my $precurfile = $_;
	my $curfile = "$outpath\/genes/$precurfile";
	#get species name
	my @S1 = split '\/', $curfile;
	my @S2 = split '\.', $S1[-1];
	my $spec = $S2[0];
	#insert in %specis
	#sort file and remove blanks
	my $curfile_nb = "$outpath\/$spec\_nb\.bed";
	my $curfile_sorted = "$outpath\/$spec\_sorted\.bed";
	my $curfile_sorteduniq = "$tmpfolder\/$spec\.bed";
	my $cmdnoblanks = "awk \'NF\' $curfile \> $curfile_nb";
	#sort by chr, elemstart, elemend
	my $col1 = 1;
	my $col3 = 3;
	my $col4 = 4;
	my $coln = "n";
	my $cmdsort = "sort -k$col1,$col1 -k$col3,$col3$coln -k$col4,$col4$coln $curfile_nb \> $curfile_sorted";
	my $cmduniq = "uniq $curfile_sorted > $curfile_sorteduniq";
	readpipe("$cmdnoblanks");
	readpipe("$cmdsort");
	readpipe("$cmduniq");
	my $rmcmd = "rm $curfile_nb $curfile_sorted";
	readpipe("$rmcmd");
    }
    my $genesrm = "rm -r $outpath\/genes";
    my $genesmv = "mv $tmpfolder $outpath\/genes";
    readpipe("$genesrm");
    readpipe("$genesmv");


    
    
}


sub checkInfernalOut{
    ##format of output lists in gene folder: chr spec_id start end strand blockl blockr struc seq infernal_score
    ##edit format into chr spec_id start end strand blockl blockr struc seq type pseudo comment
    ##check infernal scores for each species, min, max, sum, num
    my @inp = @_;
    my $outpath = $inp[0];
    my $pseudoscore = $inp[1];
    my $tmplist = "$outpath\/list_genesfiles";
    my $lscmd = "ls $outpath\/genes > $tmplist";
    readpipe("$lscmd");
    my $res = "Infernal scores are shown in the last column of the gene tables.\n";
    my %spec2min = ();
    my %spec2max = ();
    my %spec2sum = ();
    my %spec2num = ();
    open FB,"$tmplist" or die "can't open $tmplist\n";
    while(<FB>){
	chomp;
	#move current file to other name such that the original name can be used for the edited files
	my $curfile = $_;
	my @C = split '\.', $curfile;
	my $curspec = $C[0];
	my $newfile = "$outpath\/genes/$curspec\_new\.bed";
	open(my $outf, ">>", $newfile);
	$spec2min{$curspec} = 1000000;
	$spec2max{$curspec} = 0;
	$spec2sum{$curspec} = 0;	
	$spec2num{$curspec} = 0;
	my $pseucount = 0;
	open FA,"$outpath\/genes/$curfile" or die "can't open $outpath\/genes/$curfile\n";
	while(<FA>){
	    chomp;
	    my $line = $_;
	    if($line eq "" || $line =~/^#/){print $outf "$line\n"; next;}
	    my @F = split "\t", $line;
	    my $infscore = $F[9];
	    $spec2num{$curspec}++;
	    $spec2sum{$curspec}+= $infscore;
	    if($infscore < $spec2min{$curspec}){$spec2min{$curspec}=$infscore;}
	    if($infscore > $spec2max{$curspec}){$spec2max{$curspec}=$infscore;}
	    my $type = "type";
	    $F[9] = $type;
	    my $pseu = "FALSE";
	    if($pseudoscore > -1 && $infscore < $pseudoscore){$pseu = "TRUE";$pseucount++;}
	    push @F, $pseu;
	    push @F, $infscore; #this is the comment section
	    my $outstr = join("\t",@F);
	    print $outf "$outstr\n";
	}
	my $rmcmd = "rm $outpath\/genes/$curfile";
	readpipe("$rmcmd");
	my $mvcmd = "mv $newfile $outpath\/genes/$curfile";
	readpipe("$mvcmd");
	close $outf;
	my $avscore = sprintf "%.2f",$spec2sum{$curspec}/$spec2num{$curspec};
	$res = "$res Genes belonging to $curspec have an average infernal score of $avscore
with $spec2num{$curspec} genes in total. The maximum score is $spec2max{$curspec} and
the minimal score is $spec2min{$curspec}.";
	if($pseudoscore > -1){$res = "$res The threshold
splitting pseudogenes and functional genes is $pseudoscore.
This results in $pseucount pseudogenes.";}
	else{$res = "$res No threshold splitting pseudogenes and
functional genes was given (option --pseudo).";}
	$res = "$res\n";
    }
    return $res;
}
